// Copyright (c) 2010 LearnBoost <tj@learnboost.com>

#include "CanvasRenderingContext2d.h"

#include <algorithm>
#include "backend/ImageBackend.h"
#include <cairo-pdf.h>
#include "Canvas.h"
#include "CanvasGradient.h"
#include "CanvasPattern.h"
#include <cmath>
#include <cstdlib>
#include "Image.h"
#include "ImageData.h"
#include <limits>
#include <map>
#include "Point.h"
#include <string>
#include "Util.h"
#include <vector>

using namespace Napi;

Napi::FunctionReference Context2d::constructor;

/*
 * Rectangle arg assertions.
 */

#define RECT_ARGS \
  double args[4]; \
  if(!checkArgs(info, args, 4)) \
    return; \
  double x = args[0]; \
  double y = args[1]; \
  double width = args[2]; \
  double height = args[3];

#define CHECK_RECEIVER(prop) \
  if (!Context2d::constructor.Get(info.GetIsolate())->HasInstance(info.This())) { \
    Napi::TypeError::New(env, "Method " #prop " called on incompatible receiver").ThrowAsJavaScriptException();
 \
    return; \
  }

constexpr double twoPi = M_PI * 2.;

/*
 * Simple helper macro for a rather verbose function call.
 */

#define PANGO_LAYOUT_GET_METRICS(LAYOUT) pango_context_get_metrics( \
   pango_layout_get_context(LAYOUT), \
   pango_layout_get_font_description(LAYOUT), \
   pango_context_get_language(pango_layout_get_context(LAYOUT)))

inline static bool checkArgs(const Napi::CallbackInfo&info, double *args, int argsNum, int offset = 0){
  int argsEnd = offset + argsNum;
  bool areArgsValid = true;

  for (int i = offset; i < argsEnd; i++) {
    double val = info[i].As<Napi::Number>().DoubleValue().FromMaybe(0);

    if (areArgsValid) {
      if (!std::isfinite(val)) {
        // We should continue the loop instead of returning immediately
        // See https://html.spec.whatwg.org/multipage/canvas.html

        areArgsValid = false;
        continue;
      }

      args[i - offset] = val;
    }
  }

  return areArgsValid;
}

Napi::FunctionReference Context2d::_DOMMatrix;
Napi::FunctionReference Context2d::_parseFont;

/*
 * Initialize Context2d.
 */

void
Context2d::Initialize(Napi::Env& env, Napi::Object& target) {
  Napi::HandleScope scope(env);

  // Constructor
  Napi::FunctionReference ctor = Napi::Function::New(env, Context2d::New);
  constructor.Reset(ctor);

  ctor->SetClassName(Napi::String::New(env, "CanvasRenderingContext2D"));

  // Prototype
  Local<ObjectTemplate> proto = ctor->PrototypeTemplate();
  InstanceMethod("drawImage", &DrawImage),
  InstanceMethod("putImageData", &PutImageData),
  InstanceMethod("getImageData", &GetImageData),
  InstanceMethod("createImageData", &CreateImageData),
  InstanceMethod("addPage", &AddPage),
  InstanceMethod("save", &Save),
  InstanceMethod("restore", &Restore),
  InstanceMethod("rotate", &Rotate),
  InstanceMethod("translate", &Translate),
  InstanceMethod("transform", &Transform),
  InstanceMethod("getTransform", &GetTransform),
  InstanceMethod("resetTransform", &ResetTransform),
  InstanceMethod("setTransform", &SetTransform),
  InstanceMethod("isPointInPath", &IsPointInPath),
  InstanceMethod("scale", &Scale),
  InstanceMethod("clip", &Clip),
  InstanceMethod("fill", &Fill),
  InstanceMethod("stroke", &Stroke),
  InstanceMethod("fillText", &FillText),
  InstanceMethod("strokeText", &StrokeText),
  InstanceMethod("fillRect", &FillRect),
  InstanceMethod("strokeRect", &StrokeRect),
  InstanceMethod("clearRect", &ClearRect),
  InstanceMethod("rect", &Rect),
  InstanceMethod("roundRect", &RoundRect),
  InstanceMethod("measureText", &MeasureText),
  InstanceMethod("moveTo", &MoveTo),
  InstanceMethod("lineTo", &LineTo),
  InstanceMethod("bezierCurveTo", &BezierCurveTo),
  InstanceMethod("quadraticCurveTo", &QuadraticCurveTo),
  InstanceMethod("beginPath", &BeginPath),
  InstanceMethod("closePath", &ClosePath),
  InstanceMethod("arc", &Arc),
  InstanceMethod("arcTo", &ArcTo),
  InstanceMethod("ellipse", &Ellipse),
  InstanceMethod("setLineDash", &SetLineDash),
  InstanceMethod("getLineDash", &GetLineDash),
  InstanceMethod("createPattern", &CreatePattern),
  InstanceMethod("createLinearGradient", &CreateLinearGradient),
  InstanceMethod("createRadialGradient", &CreateRadialGradient),
  Napi::SetAccessor(proto, Napi::String::New(env, "pixelFormat"), GetFormat);
  Napi::SetAccessor(proto, Napi::String::New(env, "patternQuality"), GetPatternQuality, SetPatternQuality);
  Napi::SetAccessor(proto, Napi::String::New(env, "imageSmoothingEnabled"), GetImageSmoothingEnabled, SetImageSmoothingEnabled);
  Napi::SetAccessor(proto, Napi::String::New(env, "globalCompositeOperation"), GetGlobalCompositeOperation, SetGlobalCompositeOperation);
  Napi::SetAccessor(proto, Napi::String::New(env, "globalAlpha"), GetGlobalAlpha, SetGlobalAlpha);
  Napi::SetAccessor(proto, Napi::String::New(env, "shadowColor"), GetShadowColor, SetShadowColor);
  Napi::SetAccessor(proto, Napi::String::New(env, "miterLimit"), GetMiterLimit, SetMiterLimit);
  Napi::SetAccessor(proto, Napi::String::New(env, "lineWidth"), GetLineWidth, SetLineWidth);
  Napi::SetAccessor(proto, Napi::String::New(env, "lineCap"), GetLineCap, SetLineCap);
  Napi::SetAccessor(proto, Napi::String::New(env, "lineJoin"), GetLineJoin, SetLineJoin);
  Napi::SetAccessor(proto, Napi::String::New(env, "lineDashOffset"), GetLineDashOffset, SetLineDashOffset);
  Napi::SetAccessor(proto, Napi::String::New(env, "shadowOffsetX"), GetShadowOffsetX, SetShadowOffsetX);
  Napi::SetAccessor(proto, Napi::String::New(env, "shadowOffsetY"), GetShadowOffsetY, SetShadowOffsetY);
  Napi::SetAccessor(proto, Napi::String::New(env, "shadowBlur"), GetShadowBlur, SetShadowBlur);
  Napi::SetAccessor(proto, Napi::String::New(env, "antialias"), GetAntiAlias, SetAntiAlias);
  Napi::SetAccessor(proto, Napi::String::New(env, "textDrawingMode"), GetTextDrawingMode, SetTextDrawingMode);
  Napi::SetAccessor(proto, Napi::String::New(env, "quality"), GetQuality, SetQuality);
  Napi::SetAccessor(proto, Napi::String::New(env, "currentTransform"), GetCurrentTransform, SetCurrentTransform);
  Napi::SetAccessor(proto, Napi::String::New(env, "fillStyle"), GetFillStyle, SetFillStyle);
  Napi::SetAccessor(proto, Napi::String::New(env, "strokeStyle"), GetStrokeStyle, SetStrokeStyle);
  Napi::SetAccessor(proto, Napi::String::New(env, "font"), GetFont, SetFont);
  Napi::SetAccessor(proto, Napi::String::New(env, "textBaseline"), GetTextBaseline, SetTextBaseline);
  Napi::SetAccessor(proto, Napi::String::New(env, "textAlign"), GetTextAlign, SetTextAlign);
  Local<Context> ctx = Napi::GetCurrentContext();
  (target).Set(Napi::String::New(env, "CanvasRenderingContext2d"), ctor->GetFunction(ctx));
  (target).Set(Napi::String::New(env, "CanvasRenderingContext2dInit"), Napi::Function::New(env, SaveExternalModules));
}

/*
 * Create a cairo context.
 */

Context2d::Context2d(Canvas *canvas) {
  _canvas = canvas;
  _context = canvas->createCairoContext();
  _layout = pango_cairo_create_layout(_context);

  // As of January 2023, Pango rounds glyph positions which renders text wider
  // or narrower than the browser. See #2184 for more information
#if PANGO_VERSION_CHECK(1, 44, 0)
  pango_context_set_round_glyph_positions(pango_layout_get_context(_layout), FALSE);
#endif

  states.emplace();
  state = &states.top();
  pango_layout_set_font_description(_layout, state->fontDescription);
}

/*
 * Destroy cairo context.
 */

Context2d::~Context2d() {
  g_object_unref(_layout);
  cairo_destroy(_context);
  _resetPersistentHandles();
}

/*
 * Reset canvas state.
 */

void Context2d::resetState() {
  states.pop();
  states.emplace();
  pango_layout_set_font_description(_layout, state->fontDescription);
  _resetPersistentHandles();
}

void Context2d::_resetPersistentHandles() {
  _fillStyle.Reset();
  _strokeStyle.Reset();
}

/*
 * Save cairo / canvas state.
 */

void
Context2d::save() {
  cairo_save(_context);
  states.emplace(states.top());
  state = &states.top();
}

/*
 * Restore cairo / canvas state.
 */

void
Context2d::restore() {
  if (states.size() > 1) {
    cairo_restore(_context);
    states.pop();
    state = &states.top();
    pango_layout_set_font_description(_layout, state->fontDescription);
  }
}

/*
 * Save flat path.
 */

void
Context2d::savePath() {
  _path = cairo_copy_path_flat(_context);
  cairo_new_path(_context);
}

/*
 * Restore flat path.
 */

void
Context2d::restorePath() {
  cairo_new_path(_context);
  cairo_append_path(_context, _path);
  cairo_path_destroy(_path);
}

/*
 * Create temporary surface for gradient or pattern transparency
 */
cairo_pattern_t*
create_transparent_gradient(cairo_pattern_t *source, float alpha) {
  double x0;
  double y0;
  double x1;
  double y1;
  double r0;
  double r1;
  int count;
  int i;
  double offset;
  double r;
  double g;
  double b;
  double a;
  cairo_pattern_t *newGradient;
  cairo_pattern_type_t type = cairo_pattern_get_type(source);
  cairo_pattern_get_color_stop_count(source, &count);
  if (type == CAIRO_PATTERN_TYPE_LINEAR) {
    cairo_pattern_get_linear_points (source, &x0, &y0, &x1, &y1);
    newGradient = cairo_pattern_create_linear(x0, y0, x1, y1);
  } else if (type == CAIRO_PATTERN_TYPE_RADIAL) {
    cairo_pattern_get_radial_circles(source, &x0, &y0, &r0, &x1, &y1, &r1);
    newGradient = cairo_pattern_create_radial(x0, y0, r0, x1, y1, r1);
  } else {
    Napi::Error::New(env, "Unexpected gradient type").ThrowAsJavaScriptException();

    return NULL;
  }
  for ( i = 0; i < count; i++ ) {
    cairo_pattern_get_color_stop_rgba(source, i, &offset, &r, &g, &b, &a);
    cairo_pattern_add_color_stop_rgba(newGradient, offset, r, g, b, a * alpha);
  }
  return newGradient;
}

cairo_pattern_t*
create_transparent_pattern(cairo_pattern_t *source, float alpha) {
  cairo_surface_t *surface;
  cairo_pattern_get_surface(source, &surface);
  int width = cairo_image_surface_get_width(surface);
  int height = cairo_image_surface_get_height(surface);
  cairo_surface_t *mask_surface = cairo_image_surface_create(
    CAIRO_FORMAT_ARGB32,
    width,
    height);
  cairo_t *mask_context = cairo_create(mask_surface);
  if (cairo_status(mask_context) != CAIRO_STATUS_SUCCESS) {
    Napi::Error::New(env, "Failed to initialize context").ThrowAsJavaScriptException();

    return NULL;
  }
  cairo_set_source(mask_context, source);
  cairo_paint_with_alpha(mask_context, alpha);
  cairo_destroy(mask_context);
  cairo_pattern_t* newPattern = cairo_pattern_create_for_surface(mask_surface);
  cairo_surface_destroy(mask_surface);
  return newPattern;
}

/*
 * Fill and apply shadow.
 */

void
Context2d::setFillRule(Napi::Value value) {
  Napi::Env env = value.Env();
  cairo_fill_rule_t rule = CAIRO_FILL_RULE_WINDING;
  if (value.IsString()) {
    std::string str = value.As<Napi::String>();
    if (std::strcmp(*str, "evenodd") == 0) {
      rule = CAIRO_FILL_RULE_EVEN_ODD;
    }
  }
  cairo_set_fill_rule(_context, rule);
}

void
Context2d::fill(bool preserve) {
  cairo_pattern_t *new_pattern;
  bool needsRestore = false;
  if (state->fillPattern) {
    if (state->globalAlpha < 1) {
      new_pattern = create_transparent_pattern(state->fillPattern, state->globalAlpha);
      if (new_pattern == NULL) {
        // failed to allocate; Napi::ThrowError has already been called, so return from this fn.
        return;
      }
      cairo_set_source(_context, new_pattern);
      cairo_pattern_destroy(new_pattern);
    } else {
      cairo_pattern_set_filter(state->fillPattern, state->patternQuality);
      cairo_set_source(_context, state->fillPattern);
    }
    repeat_type_t repeat = Pattern::get_repeat_type_for_cairo_pattern(state->fillPattern);
    if (repeat == NO_REPEAT) {
      cairo_pattern_set_extend(cairo_get_source(_context), CAIRO_EXTEND_NONE);
    } else if (repeat == REPEAT) {
      cairo_pattern_set_extend(cairo_get_source(_context), CAIRO_EXTEND_REPEAT);
    } else {
      cairo_save(_context);
      cairo_path_t *savedPath = cairo_copy_path(_context);
      cairo_surface_t *patternSurface = nullptr;
      cairo_pattern_get_surface(cairo_get_source(_context), &patternSurface);

      double width, height;
      if (repeat == REPEAT_X) {
        double x1, x2;
        cairo_path_extents(_context, &x1, nullptr, &x2, nullptr);
        width = x2 - x1;
        height = cairo_image_surface_get_height(patternSurface);
      } else {
        double y1, y2;
        cairo_path_extents(_context, nullptr, &y1, nullptr, &y2);
        width = cairo_image_surface_get_width(patternSurface);
        height = y2 - y1;
      }
      
      cairo_new_path(_context);
      cairo_rectangle(_context, 0, 0, width, height);
      cairo_clip(_context);
      cairo_append_path(_context, savedPath);
      cairo_path_destroy(savedPath);
      cairo_pattern_set_extend(cairo_get_source(_context), CAIRO_EXTEND_REPEAT);
      needsRestore = true;
    }
  } else if (state->fillGradient) {
    if (state->globalAlpha < 1) {
      new_pattern = create_transparent_gradient(state->fillGradient, state->globalAlpha);
      if (new_pattern == NULL) {
        // failed to recognize gradient; Napi::ThrowError has already been called, so return from this fn.
        return;
      }
      cairo_pattern_set_filter(new_pattern, state->patternQuality);
      cairo_set_source(_context, new_pattern);
      cairo_pattern_destroy(new_pattern);
    } else {
      cairo_pattern_set_filter(state->fillGradient, state->patternQuality);
      cairo_set_source(_context, state->fillGradient);
    }
  } else {
    setSourceRGBA(state->fill);
  }
  if (preserve) {
    hasShadow()
      ? shadow(cairo_fill_preserve)
      : cairo_fill_preserve(_context);
  } else {
    hasShadow()
      ? shadow(cairo_fill)
      : cairo_fill(_context);
  }
  if (needsRestore) {
    cairo_restore(_context);
  }
}

/*
 * Stroke and apply shadow.
 */

void
Context2d::stroke(bool preserve) {
  cairo_pattern_t *new_pattern;
  if (state->strokePattern) {
    if (state->globalAlpha < 1) {
      new_pattern = create_transparent_pattern(state->strokePattern, state->globalAlpha);
      if (new_pattern == NULL) {
        // failed to allocate; Napi::ThrowError has already been called, so return from this fn.
        return;
      }
      cairo_set_source(_context, new_pattern);
      cairo_pattern_destroy(new_pattern);
    } else {
      cairo_pattern_set_filter(state->strokePattern, state->patternQuality);
      cairo_set_source(_context, state->strokePattern);
    }
    repeat_type_t repeat = Pattern::get_repeat_type_for_cairo_pattern(state->strokePattern);
    if (NO_REPEAT == repeat) {
      cairo_pattern_set_extend(cairo_get_source(_context), CAIRO_EXTEND_NONE);
    } else {
      cairo_pattern_set_extend(cairo_get_source(_context), CAIRO_EXTEND_REPEAT);
    }
  } else if (state->strokeGradient) {
    if (state->globalAlpha < 1) {
      new_pattern = create_transparent_gradient(state->strokeGradient, state->globalAlpha);
      if (new_pattern == NULL) {
        // failed to recognize gradient; Napi::ThrowError has already been called, so return from this fn.
        return;
      }
      cairo_pattern_set_filter(new_pattern, state->patternQuality);
      cairo_set_source(_context, new_pattern);
      cairo_pattern_destroy(new_pattern);
    } else {
      cairo_pattern_set_filter(state->strokeGradient, state->patternQuality);
      cairo_set_source(_context, state->strokeGradient);
    }
  } else {
    setSourceRGBA(state->stroke);
  }

  if (preserve) {
    hasShadow()
      ? shadow(cairo_stroke_preserve)
      : cairo_stroke_preserve(_context);
  } else {
    hasShadow()
      ? shadow(cairo_stroke)
      : cairo_stroke(_context);
  }
}

/*
 * Apply shadow with the given draw fn.
 */

void
Context2d::shadow(void (fn)(cairo_t *cr)) {
  cairo_path_t *path = cairo_copy_path_flat(_context);
  cairo_save(_context);

  // shadowOffset is unaffected by current transform
  cairo_matrix_t path_matrix;
  cairo_get_matrix(_context, &path_matrix);
  cairo_identity_matrix(_context);

  // Apply shadow
  cairo_push_group(_context);

  // No need to invoke blur if shadowBlur is 0
  if (state->shadowBlur) {
    // find out extent of path
    double x1, y1, x2, y2;
    if (fn == cairo_fill || fn == cairo_fill_preserve) {
      cairo_fill_extents(_context, &x1, &y1, &x2, &y2);
    } else {
      cairo_stroke_extents(_context, &x1, &y1, &x2, &y2);
    }

    // create new image surface that size + padding for blurring
    double dx = x2-x1, dy = y2-y1;
    cairo_user_to_device_distance(_context, &dx, &dy);
    int pad = state->shadowBlur * 2;
    cairo_surface_t *shadow_surface = cairo_image_surface_create(
      CAIRO_FORMAT_ARGB32,
      dx + 2 * pad,
      dy + 2 * pad);
    cairo_t *shadow_context = cairo_create(shadow_surface);

    // transform path to the right place
    cairo_translate(shadow_context, pad-x1, pad-y1);
    cairo_transform(shadow_context, &path_matrix);

    // set lineCap lineJoin lineDash
    cairo_set_line_cap(shadow_context, cairo_get_line_cap(_context));
    cairo_set_line_join(shadow_context, cairo_get_line_join(_context));

    double offset;
    int dashes = cairo_get_dash_count(_context);
    std::vector<double> a(dashes);
    cairo_get_dash(_context, a.data(), &offset);
    cairo_set_dash(shadow_context, a.data(), dashes, offset);

    // draw the path and blur
    cairo_set_line_width(shadow_context, cairo_get_line_width(_context));
    cairo_new_path(shadow_context);
    cairo_append_path(shadow_context, path);
    setSourceRGBA(shadow_context, state->shadow);
    fn(shadow_context);
    blur(shadow_surface, state->shadowBlur);

    // paint to original context
    cairo_set_source_surface(_context, shadow_surface,
      x1 - pad + state->shadowOffsetX + 1,
      y1 - pad + state->shadowOffsetY + 1);
    cairo_paint(_context);
    cairo_destroy(shadow_context);
    cairo_surface_destroy(shadow_surface);
  } else {
    // Offset first, then apply path's transform
    cairo_translate(
        _context
      , state->shadowOffsetX
      , state->shadowOffsetY);
    cairo_transform(_context, &path_matrix);

    // Apply shadow
    cairo_new_path(_context);
    cairo_append_path(_context, path);
    setSourceRGBA(state->shadow);

    fn(_context);
  }

  // Paint the shadow
  cairo_pop_group_to_source(_context);
  cairo_paint(_context);

  // Restore state
  cairo_restore(_context);
  cairo_new_path(_context);
  cairo_append_path(_context, path);
  fn(_context);

  cairo_path_destroy(path);
}

/*
 * Set source RGBA for the current context
 */

void
Context2d::setSourceRGBA(rgba_t color) {
  setSourceRGBA(_context, color);
}

/*
 * Set source RGBA
 */

void
Context2d::setSourceRGBA(cairo_t *ctx, rgba_t color) {
  cairo_set_source_rgba(
      ctx
    , color.r
    , color.g
    , color.b
    , color.a * state->globalAlpha);
}

/*
 * Check if the context has a drawable shadow.
 */

bool
Context2d::hasShadow() {
  return state->shadow.a
    && (state->shadowBlur || state->shadowOffsetX || state->shadowOffsetY);
}

/*
 * Blur the given surface with the given radius.
 */

void
Context2d::blur(cairo_surface_t *surface, int radius) {
  // Steve Hanov, 2009
  // Released into the public domain.
  radius = radius * 0.57735f + 0.5f;
  // get width, height
  int width = cairo_image_surface_get_width( surface );
  int height = cairo_image_surface_get_height( surface );
  unsigned* precalc =
      (unsigned*)malloc(width*height*sizeof(unsigned));
  cairo_surface_flush( surface );
  unsigned char* src = cairo_image_surface_get_data( surface );
  double mul=1.f/((radius*2)*(radius*2));
  int channel;

  // The number of times to perform the averaging. According to wikipedia,
  // three iterations is good enough to pass for a gaussian.
  const int MAX_ITERATIONS = 3;
  int iteration;

  for ( iteration = 0; iteration < MAX_ITERATIONS; iteration++ ) {
      for( channel = 0; channel < 4; channel++ ) {
          int x,y;

          // precomputation step.
          unsigned char* pix = src;
          unsigned* pre = precalc;

          pix += channel;
          for (y=0;y<height;y++) {
              for (x=0;x<width;x++) {
                  int tot=pix[0];
                  if (x>0) tot+=pre[-1];
                  if (y>0) tot+=pre[-width];
                  if (x>0 && y>0) tot-=pre[-width-1];
                  *pre++=tot;
                  pix += 4;
              }
          }

          // blur step.
          pix = src + (int)radius * width * 4 + (int)radius * 4 + channel;
          for (y=radius;y<height-radius;y++) {
              for (x=radius;x<width-radius;x++) {
                  int l = x < radius ? 0 : x - radius;
                  int t = y < radius ? 0 : y - radius;
                  int r = x + radius >= width ? width - 1 : x + radius;
                  int b = y + radius >= height ? height - 1 : y + radius;
                  int tot = precalc[r+b*width] + precalc[l+t*width] -
                      precalc[l+b*width] - precalc[r+t*width];
                  *pix=(unsigned char)(tot*mul);
                  pix += 4;
              }
              pix += (int)radius * 2 * 4;
          }
      }
  }

  cairo_surface_mark_dirty(surface);
  free(precalc);
}

/*
 * Initialize a new Context2d with the given canvas.
 */

Napi::Value Context2d::New(const Napi::CallbackInfo& info) {
  if (!info.IsConstructCall()) {
    Napi::TypeError::New(env, "Class constructors cannot be invoked without 'new'").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (!info[0].IsObject())
    Napi::TypeError::New(env, "Canvas expected").ThrowAsJavaScriptException();
    return env.Null();
  Napi::Object obj = info[0].To<Napi::Object>();
  if (!Napi::New(env, Canvas::constructor)->HasInstance(obj))
    Napi::TypeError::New(env, "Canvas expected").ThrowAsJavaScriptException();
    return env.Null();
  Canvas *canvas = obj.Unwrap<Canvas>();

  bool isImageBackend = canvas->backend()->getName() == "image";
  if (isImageBackend) {
    cairo_format_t format = ImageBackend::DEFAULT_FORMAT;
    if (info[1].IsObject()) {
      Napi::Object ctxAttributes = info[1].To<Napi::Object>();

      Napi::Value pixelFormat = (ctxAttributes).Get(Napi::String::New(env, "pixelFormat"));
      if (pixelFormat.IsString()) {
        std::string utf8PixelFormat = pixelFormat.As<Napi::String>();
        if (!strcmp(*utf8PixelFormat, "RGBA32")) format = CAIRO_FORMAT_ARGB32;
        else if (!strcmp(*utf8PixelFormat, "RGB24")) format = CAIRO_FORMAT_RGB24;
        else if (!strcmp(*utf8PixelFormat, "A8")) format = CAIRO_FORMAT_A8;
        else if (!strcmp(*utf8PixelFormat, "RGB16_565")) format = CAIRO_FORMAT_RGB16_565;
        else if (!strcmp(*utf8PixelFormat, "A1")) format = CAIRO_FORMAT_A1;
#ifdef CAIRO_FORMAT_RGB30
        else if (!strcmp(utf8PixelFormat, "RGB30")) format = CAIRO_FORMAT_RGB30;
#endif
      }

      // alpha: false forces use of RGB24
      Napi::Value alpha = (ctxAttributes).Get(Napi::String::New(env, "alpha"));
      if (alpha->IsBoolean() && !alpha.As<Napi::Boolean>().Value().FromMaybe(false)) {
        format = CAIRO_FORMAT_RGB24;
      }
    }
    static_cast<ImageBackend*>(canvas->backend())->setFormat(format);
  }

  Context2d *context = new Context2d(canvas);

  context->Wrap(info.This());
  return info.This();
}

/*
 * Save some external modules as private references.
 */

Napi::Value Context2d::SaveExternalModules(const Napi::CallbackInfo& info) {
  _DOMMatrix.Reset(info[0].To<Napi::Function>());
  _parseFont.Reset(info[1].To<Napi::Function>());
}

/*
* Get format (string).
*/

Napi::Value Context2d::GetFormat(const Napi::CallbackInfo& info) {
  CHECK_RECEIVER(Context2d.GetFormat);
  Context2d *context = info.This().Unwrap<Context2d>();
  std::string pixelFormatString;
  switch (context->canvas()->backend()->getFormat()) {
  case CAIRO_FORMAT_ARGB32: pixelFormatString = "RGBA32"; break;
  case CAIRO_FORMAT_RGB24: pixelFormatString = "RGB24"; break;
  case CAIRO_FORMAT_A8: pixelFormatString = "A8"; break;
  case CAIRO_FORMAT_A1: pixelFormatString = "A1"; break;
  case CAIRO_FORMAT_RGB16_565: pixelFormatString = "RGB16_565"; break;
#ifdef CAIRO_FORMAT_RGB30
  case CAIRO_FORMAT_RGB30: pixelFormatString = "RGB30"; break;
#endif
  default: return info.GetReturnValue().SetNull();
  }
  return Napi::String::New(env, pixelFormatString);
}

/*
 * Create a new page.
 */

Napi::Value Context2d::AddPage(const Napi::CallbackInfo& info) {
  Context2d *context = info.This().Unwrap<Context2d>();
  if (context->canvas()->backend()->getName() != "pdf") {
    Napi::Error::New(env, "only PDF canvases support .addPage()").ThrowAsJavaScriptException();
    return env.Null();
  }
  cairo_show_page(context->context());
  int width = info[0].As<Napi::Number>().Int32Value().FromMaybe(0);
  int height = info[1].As<Napi::Number>().Int32Value().FromMaybe(0);
  if (width < 1) width = context->canvas()->getWidth();
  if (height < 1) height = context->canvas()->getHeight();
  cairo_pdf_surface_set_size(context->canvas()->surface(), width, height);
  return;
}

/*
 * Put image data.
 *
 *  - imageData, dx, dy
 *  - imageData, dx, dy, sx, sy, sw, sh
 *
 */

Napi::Value Context2d::PutImageData(const Napi::CallbackInfo& info) {
  if (!info[0].IsObject())
    Napi::TypeError::New(env, "ImageData expected").ThrowAsJavaScriptException();
    return env.Null();
  Napi::Object obj = info[0].To<Napi::Object>();
  if (!Napi::New(env, ImageData::constructor)->HasInstance(obj))
    Napi::TypeError::New(env, "ImageData expected").ThrowAsJavaScriptException();
    return env.Null();

  Context2d *context = info.This().Unwrap<Context2d>();
  ImageData *imageData = obj.Unwrap<ImageData>();

  uint8_t *src = imageData->data();
  uint8_t *dst = context->canvas()->data();

  int dstStride = context->canvas()->stride();
  int Bpp = dstStride / context->canvas()->getWidth();
  int srcStride = Bpp * imageData->width();

  int sx = 0
    , sy = 0
    , sw = 0
    , sh = 0
    , dx = info[1].As<Napi::Number>().Int32Value().FromMaybe(0)
    , dy = info[2].As<Napi::Number>().Int32Value().FromMaybe(0)
    , rows
    , cols;

  switch (info.Length()) {
    // imageData, dx, dy
    case 3:
      sw = imageData->width();
      sh = imageData->height();
      break;
    // imageData, dx, dy, sx, sy, sw, sh
    case 7:
      sx = info[3].As<Napi::Number>().Int32Value().FromMaybe(0);
      sy = info[4].As<Napi::Number>().Int32Value().FromMaybe(0);
      sw = info[5].As<Napi::Number>().Int32Value().FromMaybe(0);
      sh = info[6].As<Napi::Number>().Int32Value().FromMaybe(0);
      // fix up negative height, width
      if (sw < 0) sx += sw, sw = -sw;
      if (sh < 0) sy += sh, sh = -sh;
      // clamp the left edge
      if (sx < 0) sw += sx, sx = 0;
      if (sy < 0) sh += sy, sy = 0;
      // clamp the right edge
      if (sx + sw > imageData->width()) sw = imageData->width() - sx;
      if (sy + sh > imageData->height()) sh = imageData->height() - sy;
      // start destination at source offset
      dx += sx;
      dy += sy;
      break;
    default:
      Napi::Error::New(env, "invalid arguments").ThrowAsJavaScriptException();
      return env.Null();
  }

  // chop off outlying source data
  if (dx < 0) sw += dx, sx -= dx, dx = 0;
  if (dy < 0) sh += dy, sy -= dy, dy = 0;
  // clamp width at canvas size
  // Need to wrap std::min calls using parens to prevent macro expansion on
  // windows. See http://stackoverflow.com/questions/5004858/stdmin-gives-error
  cols = (std::min)(sw, context->canvas()->getWidth() - dx);
  rows = (std::min)(sh, context->canvas()->getHeight() - dy);

  if (cols <= 0 || rows <= 0) return;

  switch (context->canvas()->backend()->getFormat()) {
  case CAIRO_FORMAT_ARGB32: {
    src += sy * srcStride + sx * 4;
    dst += dstStride * dy + 4 * dx;
    for (int y = 0; y < rows; ++y) {
      uint8_t *dstRow = dst;
      uint8_t *srcRow = src;
      for (int x = 0; x < cols; ++x) {
        // rgba
        uint8_t r = *srcRow++;
        uint8_t g = *srcRow++;
        uint8_t b = *srcRow++;
        uint8_t a = *srcRow++;

        // argb
        // performance optimization: fully transparent/opaque pixels can be
        // processed more efficiently.
        if (a == 0) {
          *dstRow++ = 0;
          *dstRow++ = 0;
          *dstRow++ = 0;
          *dstRow++ = 0;
        } else if (a == 255) {
          *dstRow++ = b;
          *dstRow++ = g;
          *dstRow++ = r;
          *dstRow++ = a;
        } else {
          float alpha = (float)a / 255;
          *dstRow++ = b * alpha;
          *dstRow++ = g * alpha;
          *dstRow++ = r * alpha;
          *dstRow++ = a;
        }
      }
      dst += dstStride;
      src += srcStride;
    }
    break;
  }
  case CAIRO_FORMAT_RGB24: {
    src += sy * srcStride + sx * 4;
    dst += dstStride * dy + 4 * dx;
    for (int y = 0; y < rows; ++y) {
      uint8_t *dstRow = dst;
      uint8_t *srcRow = src;
      for (int x = 0; x < cols; ++x) {
        // rgba
        uint8_t r = *srcRow++;
        uint8_t g = *srcRow++;
        uint8_t b = *srcRow++;
        srcRow++;

        // argb
        *dstRow++ = b;
        *dstRow++ = g;
        *dstRow++ = r;
        *dstRow++ = 255;
      }
      dst += dstStride;
      src += srcStride;
    }
    break;
  }
  case CAIRO_FORMAT_A8: {
    src += sy * srcStride + sx;
    dst += dstStride * dy + dx;
    if (srcStride == dstStride && cols == dstStride) {
      // fast path: strides are the same and doing a full-width put
      memcpy(dst, src, cols * rows);
    } else {
      for (int y = 0; y < rows; ++y) {
        memcpy(dst, src, cols);
        dst += dstStride;
        src += srcStride;
      }
    }
    break;
  }
  case CAIRO_FORMAT_A1: {
    // TODO Should this be totally packed, or maintain a stride divisible by 4?
    Napi::Error::New(env, "putImageData for CANVAS_FORMAT_A1 is not yet implemented").ThrowAsJavaScriptException();

    break;
  }
  case CAIRO_FORMAT_RGB16_565: {
    src += sy * srcStride + sx * 2;
    dst += dstStride * dy + 2 * dx;
    for (int y = 0; y < rows; ++y) {
      memcpy(dst, src, cols * 2);
      dst += dstStride;
      src += srcStride;
    }
    break;
  }
#ifdef CAIRO_FORMAT_RGB30
  case CAIRO_FORMAT_RGB30: {
    // TODO
    Napi::Error::New(env, "putImageData for CANVAS_FORMAT_RGB30 is not yet implemented").ThrowAsJavaScriptException();

    break;
  }
#endif
  default: {
    Napi::Error::New(env, "Invalid pixel format or not an image canvas").ThrowAsJavaScriptException();
    return env.Null();
  }
  }

  cairo_surface_mark_dirty_rectangle(
      context->canvas()->surface()
    , dx
    , dy
    , cols
    , rows);
}

/*
 * Get image data.
 *
 *  - sx, sy, sw, sh
 *
 */

Napi::Value Context2d::GetImageData(const Napi::CallbackInfo& info) {
  Context2d *context = info.This().Unwrap<Context2d>();
  Canvas *canvas = context->canvas();

  int sx = info[0].As<Napi::Number>().Int32Value().FromMaybe(0);
  int sy = info[1].As<Napi::Number>().Int32Value().FromMaybe(0);
  int sw = info[2].As<Napi::Number>().Int32Value().FromMaybe(0);
  int sh = info[3].As<Napi::Number>().Int32Value().FromMaybe(0);

  if (!sw)
    Napi::Error::New(env, "IndexSizeError: The source width is 0.").ThrowAsJavaScriptException();
    return env.Null();
  if (!sh)
    Napi::Error::New(env, "IndexSizeError: The source height is 0.").ThrowAsJavaScriptException();
    return env.Null();

  int width = canvas->getWidth();
  int height = canvas->getHeight();

  if (!width)
    Napi::TypeError::New(env, "Canvas width is 0").ThrowAsJavaScriptException();
    return env.Null();
  if (!height)
    Napi::TypeError::New(env, "Canvas height is 0").ThrowAsJavaScriptException();
    return env.Null();

  // WebKit and Firefox have this behavior:
  // Flip the coordinates so the origin is top/left-most:
  if (sw < 0) {
    sx += sw;
    sw = -sw;
  }
  if (sh < 0) {
    sy += sh;
    sh = -sh;
  }

  if (sx + sw > width) sw = width - sx;
  if (sy + sh > height) sh = height - sy;

  // WebKit/moz functionality. node-canvas used to return in either case.
  if (sw <= 0) sw = 1;
  if (sh <= 0) sh = 1;

  // Non-compliant. "Pixels outside the canvas must be returned as transparent
  // black." This instead clips the returned array to the canvas area.
  if (sx < 0) {
    sw += sx;
    sx = 0;
  }
  if (sy < 0) {
    sh += sy;
    sy = 0;
  }

  int srcStride = canvas->stride();
  int bpp = srcStride / width;
  int size = sw * sh * bpp;
  int dstStride = sw * bpp;

  uint8_t *src = canvas->data();

  Local<ArrayBuffer> buffer = ArrayBuffer::New(Isolate::GetCurrent(), size);
  Local<TypedArray> dataArray;

  if (canvas->backend()->getFormat() == CAIRO_FORMAT_RGB16_565) {
    dataArray = Uint16Array::New(buffer, 0, size >> 1);
  } else {
    dataArray = Uint8ClampedArray::New(buffer, 0, size);
  }

  Napi::TypedArrayContents<uint8_t> typedArrayContents(dataArray);
  uint8_t* dst = *typedArrayContents;

  switch (canvas->backend()->getFormat()) {
  case CAIRO_FORMAT_ARGB32: {
    // Rearrange alpha (argb -> rgba), undo alpha pre-multiplication,
    // and store in big-endian format
    for (int y = 0; y < sh; ++y) {
      uint32_t *row = (uint32_t *)(src + srcStride * (y + sy));
      for (int x = 0; x < sw; ++x) {
        int bx = x * 4;
        uint32_t *pixel = row + x + sx;
        uint8_t a = *pixel >> 24;
        uint8_t r = *pixel >> 16;
        uint8_t g = *pixel >> 8;
        uint8_t b = *pixel;
        dst[bx + 3] = a;

        // Performance optimization: fully transparent/opaque pixels can be
        // processed more efficiently.
        if (a == 0 || a == 255) {
          